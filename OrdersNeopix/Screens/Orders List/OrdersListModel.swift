//
//  OrdersListModel.swift
//  OrdersNeopix
//
//  Created by Uros Smiljanic on 19/02/2019.
//  Copyright Â© 2019 Uros Smiljanic. All rights reserved.
//

// Data model generated by https://app.quicktype.io/ for JSON data send from API call

import Foundation

struct OrdersModel: Codable {
    let data: [Datum]
    let meta: Meta
}

struct Datum: Codable {
    let id: Int
    let name: String
    let date: Int
    let status: Status
    let amount: Int
    let image: String
}

enum Status: String, Codable {
    case accepted = "accepted"
    case declined = "declined"
    case partiallyAccepted = "partiallyAccepted"
    case pending = "pending"
}

struct Meta: Codable {
    let hasMore: Bool
    let totalAmount: Double
}

// MARK: Convenience initializers and mutators

extension OrdersModel {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(OrdersModel.self, from: data)
    }
    
    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }
    
    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }
    
    func with(
        data: [Datum]? = nil,
        meta: Meta? = nil
        ) -> OrdersModel {
        return OrdersModel(
            data: data ?? self.data,
            meta: meta ?? self.meta
        )
    }
    
    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }
    
    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

extension Datum {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(Datum.self, from: data)
    }
    
    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }
    
    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }
    
    func with(
        id: Int? = nil,
        name: String? = nil,
        date: Int? = nil,
        status: Status? = nil,
        amount: Int? = nil,
        image: String? = nil
        ) -> Datum {
        return Datum(
            id: id ?? self.id,
            name: name ?? self.name,
            date: date ?? self.date,
            status: status ?? self.status,
            amount: amount ?? self.amount,
            image: image ?? self.image
        )
    }
    
    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }
    
    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

extension Meta {
    init(data: Data) throws {
        self = try newJSONDecoder().decode(Meta.self, from: data)
    }
    
    init(_ json: String, using encoding: String.Encoding = .utf8) throws {
        guard let data = json.data(using: encoding) else {
            throw NSError(domain: "JSONDecoding", code: 0, userInfo: nil)
        }
        try self.init(data: data)
    }
    
    init(fromURL url: URL) throws {
        try self.init(data: try Data(contentsOf: url))
    }
    
    func with(
        hasMore: Bool? = nil,
        totalAmount: Double? = nil
        ) -> Meta {
        return Meta(
            hasMore: hasMore ?? self.hasMore,
            totalAmount: totalAmount ?? self.totalAmount
        )
    }
    
    func jsonData() throws -> Data {
        return try newJSONEncoder().encode(self)
    }
    
    func jsonString(encoding: String.Encoding = .utf8) throws -> String? {
        return String(data: try self.jsonData(), encoding: encoding)
    }
}

fileprivate func newJSONDecoder() -> JSONDecoder {
    let decoder = JSONDecoder()
    if #available(iOS 10.0, OSX 10.12, tvOS 10.0, watchOS 3.0, *) {
        decoder.dateDecodingStrategy = .iso8601
    }
    return decoder
}

fileprivate func newJSONEncoder() -> JSONEncoder {
    let encoder = JSONEncoder()
    if #available(iOS 10.0, OSX 10.12, tvOS 10.0, watchOS 3.0, *) {
        encoder.dateEncodingStrategy = .iso8601
    }
    return encoder
}
